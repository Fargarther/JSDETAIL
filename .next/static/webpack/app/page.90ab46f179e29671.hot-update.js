"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/app/components/SingleLineScroll.tsx":
/*!*************************************************!*\
  !*** ./src/app/components/SingleLineScroll.tsx ***!
  \*************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ SingleLineScroll; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _pathData__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pathData */ \"(app-pages-browser)/./src/app/components/pathData.ts\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n// Map scroll progress -> path progress to control speed/lingers.\n// Edit these keyframes to change how fast the line reveals.\n// Example below slows early, speeds up, then lingers around 60%.\nconst MAIN_MAP = [\n    {\n        scroll: 0.00,\n        value: 0.00\n    },\n    {\n        scroll: 0.18,\n        value: 0.20\n    },\n    {\n        scroll: 0.35,\n        value: 0.60\n    },\n    {\n        scroll: 0.50,\n        value: 0.60\n    },\n    {\n        scroll: 0.80,\n        value: 1.00\n    },\n    {\n        scroll: 1.00,\n        value: 1.00\n    }\n];\n// Secondary path (e.g., camera) draws later while main lingers\nconst SECONDARY_MAP = [\n    {\n        scroll: 0.00,\n        value: 0.00\n    },\n    {\n        scroll: 0.50,\n        value: 0.00\n    },\n    {\n        scroll: 0.65,\n        value: 1.00\n    },\n    {\n        scroll: 1.00,\n        value: 1.00\n    }\n];\n// Dot that “spins” along the main path; accelerate on the middle segment\nconst DOT_MAP = [\n    {\n        scroll: 0.00,\n        value: 0.00\n    },\n    {\n        scroll: 0.60,\n        value: 0.60\n    },\n    {\n        scroll: 0.72,\n        value: 0.85\n    },\n    {\n        scroll: 0.80,\n        value: 0.90\n    },\n    {\n        scroll: 1.00,\n        value: 1.00\n    }\n];\nfunction mapProgress(scrollProgress, map) {\n    const p = Math.min(Math.max(scrollProgress, 0), 1);\n    for(let i = 1; i < map.length; i++){\n        if (p <= map[i].scroll) {\n            const a = map[i - 1];\n            const b = map[i];\n            const t = (p - a.scroll) / (b.scroll - a.scroll || 1);\n            return a.value + t * (b.value - a.value);\n        }\n    }\n    return map[map.length - 1].value;\n}\n// Split path data into subpaths (each starting with M/m). This avoids the\n// “pre-drawn” issue because dash patterns reset per subpath in SVG.\nfunction splitSubpaths(d) {\n    const parts = d.match(/[Mm][^Mm]*/g);\n    return parts !== null && parts !== void 0 ? parts : [\n        d\n    ];\n}\nfunction SingleLineScroll() {\n    _s();\n    const svgRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const pathRefs = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    const dotRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const subpaths = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>splitSubpaths(_pathData__WEBPACK_IMPORTED_MODULE_2__.PATH_D), []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const svg = svgRef.current;\n        const paths = pathRefs.current.filter(Boolean);\n        if (!svg || paths.length === 0) return;\n        // Prepare dash for each subpath using its own length\n        const lengths = paths.map((p)=>p.getTotalLength());\n        const total = lengths.reduce((a, b)=>a + b, 0);\n        paths.forEach((p, i)=>{\n            const L = lengths[i];\n            p.style.strokeDasharray = \"\".concat(L, \" \").concat(L);\n            p.style.strokeDashoffset = \"\".concat(L);\n        });\n        let rafId = 0;\n        const update = ()=>{\n            const scrollTop = window.pageYOffset || document.documentElement.scrollTop || 0;\n            const scrollHeight = Math.max(1, document.documentElement.scrollHeight - window.innerHeight);\n            const scrollPct = Math.min(scrollTop / scrollHeight, 1);\n            // Main path progress\n            const mainPct = mapProgress(scrollPct, MAIN_MAP);\n            // Secondary (camera) progress\n            const secondaryPct = mapProgress(scrollPct, SECONDARY_MAP);\n            // Dot progress along main subpath\n            const dotPct = mapProgress(scrollPct, DOT_MAP);\n            // Distribute progress per subpath: index 0 = main, index 1+ secondary\n            for(let i = 0; i < paths.length; i++){\n                const L = lengths[i];\n                const p = paths[i];\n                const pct = i === 0 ? mainPct : secondaryPct;\n                p.style.strokeDashoffset = \"\".concat(L - L * pct);\n            }\n            // Position the dot along the main path\n            const dot = dotRef.current;\n            const mainPath = paths[0];\n            if (dot && mainPath) {\n                const L0 = lengths[0];\n                const len = Math.max(0, Math.min(L0, L0 * dotPct));\n                const pt = mainPath.getPointAtLength(len);\n                dot.setAttribute(\"cx\", String(pt.x));\n                dot.setAttribute(\"cy\", String(pt.y));\n                // Show only during the “spin window” (60%–80% of scroll)\n                const visible = scrollPct >= 0.6 && scrollPct <= 0.85;\n                dot.setAttribute(\"opacity\", visible ? \"0.9\" : \"0\");\n            }\n        };\n        const onScroll = ()=>{\n            cancelAnimationFrame(rafId);\n            rafId = requestAnimationFrame(update);\n        };\n        window.addEventListener(\"scroll\", onScroll, {\n            passive: true\n        });\n        window.addEventListener(\"resize\", onScroll, {\n            passive: true\n        });\n        update() // Initial paint\n        ;\n        return ()=>{\n            window.removeEventListener(\"scroll\", onScroll);\n            window.removeEventListener(\"resize\", onScroll);\n            cancelAnimationFrame(rafId);\n        };\n    }, [\n        subpaths\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"fixed inset-0 pointer-events-none z-0 overflow-hidden\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n            ref: svgRef,\n            viewBox: \"0 0 4941 16570\",\n            fill: \"none\",\n            xmlns: \"http://www.w3.org/2000/svg\",\n            className: \"w-full h-auto min-h-full\",\n            preserveAspectRatio: \"xMidYMid meet\",\n            \"aria-hidden\": \"true\",\n            focusable: \"false\",\n            children: [\n                subpaths.map((d, i)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n                        ref: (el)=>{\n                            if (el) pathRefs.current[i] = el;\n                        },\n                        d: d.trim(),\n                        stroke: \"#333\",\n                        strokeWidth: \"var(--stroke-width, 3)\",\n                        fill: \"none\",\n                        vectorEffect: \"non-scaling-stroke\",\n                        className: \"transition-all duration-75 ease-linear\",\n                        style: {\n                            filter: \"drop-shadow(0 0 1px rgba(0,0,0,0.1))\"\n                        }\n                    }, i, false, {\n                        fileName: \"C:\\\\Users\\\\benso\\\\Downloads\\\\JSDETAIL\\\\src\\\\app\\\\components\\\\SingleLineScroll.tsx\",\n                        lineNumber: 140,\n                        columnNumber: 11\n                    }, this)),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"circle\", {\n                    ref: dotRef,\n                    r: \"35\",\n                    fill: \"#333\",\n                    opacity: \"0\"\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\benso\\\\Downloads\\\\JSDETAIL\\\\src\\\\app\\\\components\\\\SingleLineScroll.tsx\",\n                    lineNumber: 154,\n                    columnNumber: 9\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"C:\\\\Users\\\\benso\\\\Downloads\\\\JSDETAIL\\\\src\\\\app\\\\components\\\\SingleLineScroll.tsx\",\n            lineNumber: 129,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\benso\\\\Downloads\\\\JSDETAIL\\\\src\\\\app\\\\components\\\\SingleLineScroll.tsx\",\n        lineNumber: 128,\n        columnNumber: 5\n    }, this);\n}\n_s(SingleLineScroll, \"4Onea6HlfmujpzLW6WGwCOglzNQ=\");\n_c = SingleLineScroll;\nvar _c;\n$RefreshReg$(_c, \"SingleLineScroll\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvY29tcG9uZW50cy9TaW5nbGVMaW5lU2Nyb2xsLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBRWtEO0FBQ2Y7QUFFbkMsaUVBQWlFO0FBQ2pFLDREQUE0RDtBQUM1RCxpRUFBaUU7QUFDakUsTUFBTUksV0FBVztJQUNmO1FBQUVDLFFBQVE7UUFBTUMsT0FBTztJQUFLO0lBQzVCO1FBQUVELFFBQVE7UUFBTUMsT0FBTztJQUFLO0lBQzVCO1FBQUVELFFBQVE7UUFBTUMsT0FBTztJQUFLO0lBQzVCO1FBQUVELFFBQVE7UUFBTUMsT0FBTztJQUFLO0lBQzVCO1FBQUVELFFBQVE7UUFBTUMsT0FBTztJQUFLO0lBQzVCO1FBQUVELFFBQVE7UUFBTUMsT0FBTztJQUFLO0NBQzdCO0FBRUQsK0RBQStEO0FBQy9ELE1BQU1DLGdCQUFnQjtJQUNwQjtRQUFFRixRQUFRO1FBQU1DLE9BQU87SUFBSztJQUM1QjtRQUFFRCxRQUFRO1FBQU1DLE9BQU87SUFBSztJQUM1QjtRQUFFRCxRQUFRO1FBQU1DLE9BQU87SUFBSztJQUM1QjtRQUFFRCxRQUFRO1FBQU1DLE9BQU87SUFBSztDQUM3QjtBQUVELHlFQUF5RTtBQUN6RSxNQUFNRSxVQUFVO0lBQ2Q7UUFBRUgsUUFBUTtRQUFNQyxPQUFPO0lBQUs7SUFDNUI7UUFBRUQsUUFBUTtRQUFNQyxPQUFPO0lBQUs7SUFDNUI7UUFBRUQsUUFBUTtRQUFNQyxPQUFPO0lBQUs7SUFDNUI7UUFBRUQsUUFBUTtRQUFNQyxPQUFPO0lBQUs7SUFDNUI7UUFBRUQsUUFBUTtRQUFNQyxPQUFPO0lBQUs7Q0FDN0I7QUFFRCxTQUFTRyxZQUFZQyxjQUFzQixFQUFFQyxHQUFpRDtJQUM1RixNQUFNQyxJQUFJQyxLQUFLQyxHQUFHLENBQUNELEtBQUtFLEdBQUcsQ0FBQ0wsZ0JBQWdCLElBQUk7SUFDaEQsSUFBSyxJQUFJTSxJQUFJLEdBQUdBLElBQUlMLElBQUlNLE1BQU0sRUFBRUQsSUFBSztR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QSxJQUFJMUQsU0FBU0ksT0FBTyxDQUFDZixFQUFFLEdBQUdxRTt3QkFDaEM7d0JBQ0EvRCxHQUFHQSxFQUFFZ0UsSUFBSTt3QkFDVEMsUUFBTzt3QkFDUEMsYUFBWTt3QkFDWlQsTUFBSzt3QkFDTFUsY0FBYTt3QkFDYmIsV0FBVTt3QkFDVm5DLE9BQU87NEJBQUVSLFFBQVE7d0JBQXVDO3VCQVZuRGpCOzs7Ozs4QkFhVCw4REFBQzBFO29CQUFPYixLQUFLakQ7b0JBQVErRCxHQUFFO29CQUFLWixNQUFLO29CQUFPYSxTQUFROzs7Ozs7Ozs7Ozs7Ozs7OztBQUl4RDtHQXZHd0JuRTtLQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvYXBwL2NvbXBvbmVudHMvU2luZ2xlTGluZVNjcm9sbC50c3g/ZGRlMCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VNZW1vLCB1c2VSZWYgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IFBBVEhfRCB9IGZyb20gJy4vcGF0aERhdGEnXG5cbi8vIE1hcCBzY3JvbGwgcHJvZ3Jlc3MgLT4gcGF0aCBwcm9ncmVzcyB0byBjb250cm9sIHNwZWVkL2xpbmdlcnMuXG4vLyBFZGl0IHRoZXNlIGtleWZyYW1lcyB0byBjaGFuZ2UgaG93IGZhc3QgdGhlIGxpbmUgcmV2ZWFscy5cbi8vIEV4YW1wbGUgYmVsb3cgc2xvd3MgZWFybHksIHNwZWVkcyB1cCwgdGhlbiBsaW5nZXJzIGFyb3VuZCA2MCUuXG5jb25zdCBNQUlOX01BUCA9IFtcbiAgeyBzY3JvbGw6IDAuMDAsIHZhbHVlOiAwLjAwIH0sIC8vIHN0YXJ0XG4gIHsgc2Nyb2xsOiAwLjE4LCB2YWx1ZTogMC4yMCB9LCAvLyByZXZlYWwgYSBiaXRcbiAgeyBzY3JvbGw6IDAuMzUsIHZhbHVlOiAwLjYwIH0sIC8vIHF1aWNrIGN1cnZlL3NsaW5nIHRvIGxlZnQvYmFja1xuICB7IHNjcm9sbDogMC41MCwgdmFsdWU6IDAuNjAgfSwgLy8gbGluZ2VyIG1pZC1wYWdlXG4gIHsgc2Nyb2xsOiAwLjgwLCB2YWx1ZTogMS4wMCB9LCAvLyBmaW5pc2ggYXMgd2UgYXBwcm9hY2ggZW5kXG4gIHsgc2Nyb2xsOiAxLjAwLCB2YWx1ZTogMS4wMCB9LFxuXSBhcyBjb25zdFxuXG4vLyBTZWNvbmRhcnkgcGF0aCAoZS5nLiwgY2FtZXJhKSBkcmF3cyBsYXRlciB3aGlsZSBtYWluIGxpbmdlcnNcbmNvbnN0IFNFQ09OREFSWV9NQVAgPSBbXG4gIHsgc2Nyb2xsOiAwLjAwLCB2YWx1ZTogMC4wMCB9LFxuICB7IHNjcm9sbDogMC41MCwgdmFsdWU6IDAuMDAgfSwgLy8gaG9sZCBoaWRkZW4gZHVyaW5nIGVhcmx5IHNlY3Rpb25zXG4gIHsgc2Nyb2xsOiAwLjY1LCB2YWx1ZTogMS4wMCB9LCAvLyBkcmF3IGNhbWVyYSB3aGlsZSBsaW5nZXJpbmdcbiAgeyBzY3JvbGw6IDEuMDAsIHZhbHVlOiAxLjAwIH0sXG5dIGFzIGNvbnN0XG5cbi8vIERvdCB0aGF0IOKAnHNwaW5z4oCdIGFsb25nIHRoZSBtYWluIHBhdGg7IGFjY2VsZXJhdGUgb24gdGhlIG1pZGRsZSBzZWdtZW50XG5jb25zdCBET1RfTUFQID0gW1xuICB7IHNjcm9sbDogMC4wMCwgdmFsdWU6IDAuMDAgfSxcbiAgeyBzY3JvbGw6IDAuNjAsIHZhbHVlOiAwLjYwIH0sIC8vIGlkbGUgdW50aWwgbWlkLXBhZ2VcbiAgeyBzY3JvbGw6IDAuNzIsIHZhbHVlOiAwLjg1IH0sIC8vIHNsaW5nc2hvdCB0aHJvdWdoIGN1cnZlIChmYXN0KVxuICB7IHNjcm9sbDogMC44MCwgdmFsdWU6IDAuOTAgfSwgLy8gc2xvdyBvbiBzdHJhaWdodFxuICB7IHNjcm9sbDogMS4wMCwgdmFsdWU6IDEuMDAgfSxcbl0gYXMgY29uc3RcblxuZnVuY3Rpb24gbWFwUHJvZ3Jlc3Moc2Nyb2xsUHJvZ3Jlc3M6IG51bWJlciwgbWFwOiByZWFkb25seSB7IHNjcm9sbDogbnVtYmVyOyB2YWx1ZTogbnVtYmVyIH1bXSkge1xuICBjb25zdCBwID0gTWF0aC5taW4oTWF0aC5tYXgoc2Nyb2xsUHJvZ3Jlc3MsIDApLCAxKVxuICBmb3IgKGxldCBpID0gMTsgaSA8IG1hcC5sZW5ndGg7IGkrKykge1xuICAgIGlmIChwIDw9IG1hcFtpXS5zY3JvbGwpIHtcbiAgICAgIGNvbnN0IGEgPSBtYXBbaSAtIDFdXG4gICAgICBjb25zdCBiID0gbWFwW2ldXG4gICAgICBjb25zdCB0ID0gKHAgLSBhLnNjcm9sbCkgLyAoYi5zY3JvbGwgLSBhLnNjcm9sbCB8fCAxKVxuICAgICAgcmV0dXJuIGEudmFsdWUgKyB0ICogKGIudmFsdWUgLSBhLnZhbHVlKVxuICAgIH1cbiAgfVxuICByZXR1cm4gbWFwW21hcC5sZW5ndGggLSAxXS52YWx1ZVxufVxuXG4vLyBTcGxpdCBwYXRoIGRhdGEgaW50byBzdWJwYXRocyAoZWFjaCBzdGFydGluZyB3aXRoIE0vbSkuIFRoaXMgYXZvaWRzIHRoZVxuLy8g4oCccHJlLWRyYXdu4oCdIGlzc3VlIGJlY2F1c2UgZGFzaCBwYXR0ZXJucyByZXNldCBwZXIgc3VicGF0aCBpbiBTVkcuXG5mdW5jdGlvbiBzcGxpdFN1YnBhdGhzKGQ6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgY29uc3QgcGFydHMgPSBkLm1hdGNoKC9bTW1dW15NbV0qL2cpXG4gIHJldHVybiBwYXJ0cyA/PyBbZF1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU2luZ2xlTGluZVNjcm9sbCgpIHtcbiAgY29uc3Qgc3ZnUmVmID0gdXNlUmVmPFNWR1NWR0VsZW1lbnQ+KG51bGwpXG4gIGNvbnN0IHBhdGhSZWZzID0gdXNlUmVmPFNWR1BhdGhFbGVtZW50W10+KFtdKVxuICBjb25zdCBkb3RSZWYgPSB1c2VSZWY8U1ZHQ2lyY2xlRWxlbWVudD4obnVsbClcbiAgY29uc3Qgc3VicGF0aHMgPSB1c2VNZW1vKCgpID0+IHNwbGl0U3VicGF0aHMoUEFUSF9EKSwgW10pXG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBzdmcgPSBzdmdSZWYuY3VycmVudFxuICAgIGNvbnN0IHBhdGhzID0gcGF0aFJlZnMuY3VycmVudC5maWx0ZXIoQm9vbGVhbilcbiAgICBpZiAoIXN2ZyB8fCBwYXRocy5sZW5ndGggPT09IDApIHJldHVyblxuXG4gICAgLy8gUHJlcGFyZSBkYXNoIGZvciBlYWNoIHN1YnBhdGggdXNpbmcgaXRzIG93biBsZW5ndGhcbiAgICBjb25zdCBsZW5ndGhzID0gcGF0aHMubWFwKChwKSA9PiBwLmdldFRvdGFsTGVuZ3RoKCkpXG4gICAgY29uc3QgdG90YWwgPSBsZW5ndGhzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApXG5cbiAgICBwYXRocy5mb3JFYWNoKChwLCBpKSA9PiB7XG4gICAgICBjb25zdCBMID0gbGVuZ3Roc1tpXVxuICAgICAgcC5zdHlsZS5zdHJva2VEYXNoYXJyYXkgPSBgJHtMfSAke0x9YFxuICAgICAgcC5zdHlsZS5zdHJva2VEYXNob2Zmc2V0ID0gYCR7TH1gXG4gICAgfSlcblxuICAgIGxldCByYWZJZCA9IDBcbiAgICBjb25zdCB1cGRhdGUgPSAoKSA9PiB7XG4gICAgICBjb25zdCBzY3JvbGxUb3AgPSB3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCB8fCAwXG4gICAgICBjb25zdCBzY3JvbGxIZWlnaHQgPSBNYXRoLm1heCgxLCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0IC0gd2luZG93LmlubmVySGVpZ2h0KVxuICAgICAgY29uc3Qgc2Nyb2xsUGN0ID0gTWF0aC5taW4oc2Nyb2xsVG9wIC8gc2Nyb2xsSGVpZ2h0LCAxKVxuICAgICAgLy8gTWFpbiBwYXRoIHByb2dyZXNzXG4gICAgICBjb25zdCBtYWluUGN0ID0gbWFwUHJvZ3Jlc3Moc2Nyb2xsUGN0LCBNQUlOX01BUClcbiAgICAgIC8vIFNlY29uZGFyeSAoY2FtZXJhKSBwcm9ncmVzc1xuICAgICAgY29uc3Qgc2Vjb25kYXJ5UGN0ID0gbWFwUHJvZ3Jlc3Moc2Nyb2xsUGN0LCBTRUNPTkRBUllfTUFQKVxuICAgICAgLy8gRG90IHByb2dyZXNzIGFsb25nIG1haW4gc3VicGF0aFxuICAgICAgY29uc3QgZG90UGN0ID0gbWFwUHJvZ3Jlc3Moc2Nyb2xsUGN0LCBET1RfTUFQKVxuXG4gICAgICAvLyBEaXN0cmlidXRlIHByb2dyZXNzIHBlciBzdWJwYXRoOiBpbmRleCAwID0gbWFpbiwgaW5kZXggMSsgc2Vjb25kYXJ5XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IEwgPSBsZW5ndGhzW2ldXG4gICAgICAgIGNvbnN0IHAgPSBwYXRoc1tpXVxuICAgICAgICBjb25zdCBwY3QgPSBpID09PSAwID8gbWFpblBjdCA6IHNlY29uZGFyeVBjdFxuICAgICAgICBwLnN0eWxlLnN0cm9rZURhc2hvZmZzZXQgPSBgJHtMIC0gTCAqIHBjdH1gXG4gICAgICB9XG5cbiAgICAgIC8vIFBvc2l0aW9uIHRoZSBkb3QgYWxvbmcgdGhlIG1haW4gcGF0aFxuICAgICAgY29uc3QgZG90ID0gZG90UmVmLmN1cnJlbnRcbiAgICAgIGNvbnN0IG1haW5QYXRoID0gcGF0aHNbMF1cbiAgICAgIGlmIChkb3QgJiYgbWFpblBhdGgpIHtcbiAgICAgICAgY29uc3QgTDAgPSBsZW5ndGhzWzBdXG4gICAgICAgIGNvbnN0IGxlbiA9IE1hdGgubWF4KDAsIE1hdGgubWluKEwwLCBMMCAqIGRvdFBjdCkpXG4gICAgICAgIGNvbnN0IHB0ID0gbWFpblBhdGguZ2V0UG9pbnRBdExlbmd0aChsZW4pXG4gICAgICAgIGRvdC5zZXRBdHRyaWJ1dGUoJ2N4JywgU3RyaW5nKHB0LngpKVxuICAgICAgICBkb3Quc2V0QXR0cmlidXRlKCdjeScsIFN0cmluZyhwdC55KSlcbiAgICAgICAgLy8gU2hvdyBvbmx5IGR1cmluZyB0aGUg4oCcc3BpbiB3aW5kb3figJ0gKDYwJeKAkzgwJSBvZiBzY3JvbGwpXG4gICAgICAgIGNvbnN0IHZpc2libGUgPSBzY3JvbGxQY3QgPj0gMC42ICYmIHNjcm9sbFBjdCA8PSAwLjg1XG4gICAgICAgIGRvdC5zZXRBdHRyaWJ1dGUoJ29wYWNpdHknLCB2aXNpYmxlID8gJzAuOScgOiAnMCcpXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgb25TY3JvbGwgPSAoKSA9PiB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShyYWZJZClcbiAgICAgIHJhZklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHVwZGF0ZSlcbiAgICB9XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgb25TY3JvbGwsIHsgcGFzc2l2ZTogdHJ1ZSB9KVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBvblNjcm9sbCwgeyBwYXNzaXZlOiB0cnVlIH0pXG4gICAgdXBkYXRlKCkgLy8gSW5pdGlhbCBwYWludFxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBvblNjcm9sbClcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBvblNjcm9sbClcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZklkKVxuICAgIH1cbiAgfSwgW3N1YnBhdGhzXSlcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwiZml4ZWQgaW5zZXQtMCBwb2ludGVyLWV2ZW50cy1ub25lIHotMCBvdmVyZmxvdy1oaWRkZW5cIj5cbiAgICAgIDxzdmdcbiAgICAgICAgcmVmPXtzdmdSZWZ9XG4gICAgICAgIHZpZXdCb3g9XCIwIDAgNDk0MSAxNjU3MFwiXG4gICAgICAgIGZpbGw9XCJub25lXCJcbiAgICAgICAgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gICAgICAgIGNsYXNzTmFtZT1cInctZnVsbCBoLWF1dG8gbWluLWgtZnVsbFwiXG4gICAgICAgIHByZXNlcnZlQXNwZWN0UmF0aW89XCJ4TWlkWU1pZCBtZWV0XCJcbiAgICAgICAgYXJpYS1oaWRkZW49XCJ0cnVlXCJcbiAgICAgICAgZm9jdXNhYmxlPVwiZmFsc2VcIlxuICAgICAgPlxuICAgICAgICB7c3VicGF0aHMubWFwKChkLCBpKSA9PiAoXG4gICAgICAgICAgPHBhdGhcbiAgICAgICAgICAgIGtleT17aX1cbiAgICAgICAgICAgIHJlZj17KGVsKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChlbCkgcGF0aFJlZnMuY3VycmVudFtpXSA9IGVsXG4gICAgICAgICAgICB9fVxuICAgICAgICAgICAgZD17ZC50cmltKCl9XG4gICAgICAgICAgICBzdHJva2U9XCIjMzMzXCJcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoPVwidmFyKC0tc3Ryb2tlLXdpZHRoLCAzKVwiXG4gICAgICAgICAgICBmaWxsPVwibm9uZVwiXG4gICAgICAgICAgICB2ZWN0b3JFZmZlY3Q9XCJub24tc2NhbGluZy1zdHJva2VcIlxuICAgICAgICAgICAgY2xhc3NOYW1lPVwidHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tNzUgZWFzZS1saW5lYXJcIlxuICAgICAgICAgICAgc3R5bGU9e3sgZmlsdGVyOiAnZHJvcC1zaGFkb3coMCAwIDFweCByZ2JhKDAsMCwwLDAuMSkpJyB9fVxuICAgICAgICAgIC8+XG4gICAgICAgICkpfVxuICAgICAgICA8Y2lyY2xlIHJlZj17ZG90UmVmfSByPVwiMzVcIiBmaWxsPVwiIzMzM1wiIG9wYWNpdHk9XCIwXCIgLz5cbiAgICAgIDwvc3ZnPlxuICAgIDwvZGl2PlxuICApXG59XG4iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlTWVtbyIsInVzZVJlZiIsIlBBVEhfRCIsIk1BSU5fTUFQIiwic2Nyb2xsIiwidmFsdWUiLCJTRUNPTkRBUllfTUFQIiwiRE9UX01BUCIsIm1hcFByb2dyZXNzIiwic2Nyb2xsUHJvZ3Jlc3MiLCJtYXAiLCJwIiwiTWF0aCIsIm1pbiIsIm1heCIsImkiLCJsZW5ndGgiLCJhIiwiYiIsInQiLCJzcGxpdFN1YnBhdGhzIiwiZCIsInBhcnRzIiwibWF0Y2giLCJTaW5nbGVMaW5lU2Nyb2xsIiwic3ZnUmVmIiwicGF0aFJlZnMiLCJkb3RSZWYiLCJzdWJwYXRocyIsInN2ZyIsImN1cnJlbnQiLCJwYXRocyIsImZpbHRlciIsIkJvb2xlYW4iLCJsZW5ndGhzIiwiZ2V0VG90YWxMZW5ndGgiLCJ0b3RhbCIsInJlZHVjZSIsImZvckVhY2giLCJMIiwic3R5bGUiLCJzdHJva2VEYXNoYXJyYXkiLCJzdHJva2VEYXNob2Zmc2V0IiwicmFmSWQiLCJ1cGRhdGUiLCJzY3JvbGxUb3AiLCJ3aW5kb3ciLCJwYWdlWU9mZnNldCIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50Iiwic2Nyb2xsSGVpZ2h0IiwiaW5uZXJIZWlnaHQiLCJzY3JvbGxQY3QiLCJtYWluUGN0Iiwic2Vjb25kYXJ5UGN0IiwiZG90UGN0IiwicGN0IiwiZG90IiwibWFpblBhdGgiLCJMMCIsImxlbiIsInB0IiwiZ2V0UG9pbnRBdExlbmd0aCIsInNldEF0dHJpYnV0ZSIsIlN0cmluZyIsIngiLCJ5IiwidmlzaWJsZSIsIm9uU2Nyb2xsIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJhZGRFdmVudExpc3RlbmVyIiwicGFzc2l2ZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJkaXYiLCJjbGFzc05hbWUiLCJyZWYiLCJ2aWV3Qm94IiwiZmlsbCIsInhtbG5zIiwicHJlc2VydmVBc3BlY3RSYXRpbyIsImFyaWEtaGlkZGVuIiwiZm9jdXNhYmxlIiwicGF0aCIsImVsIiwidHJpbSIsInN0cm9rZSIsInN0cm9rZVdpZHRoIiwidmVjdG9yRWZmZWN0IiwiY2lyY2xlIiwiciIsIm9wYWNpdHkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/components/SingleLineScroll.tsx\n"));

/***/ })

});